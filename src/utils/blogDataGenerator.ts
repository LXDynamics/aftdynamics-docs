/**
 * Blog data file generation utilities
 * Used by the blog data plugin to generate TypeScript files with blog data
 */

import type { BlogArchive, BlogPost, BlogPostMetadata, BlogTag, BlogAuthor } from '../generated/types';

/**
 * Escapes a string for safe inclusion in TypeScript code
 */
function escapeString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')  // Escape backslashes
    .replace(/'/g, "\\'")    // Escape single quotes
    .replace(/"/g, '\\"')    // Escape double quotes
    .replace(/\n/g, '\\n')   // Escape newlines
    .replace(/\r/g, '\\r')   // Escape carriage returns
    .replace(/\t/g, '\\t')   // Escape tabs
    .replace(/\u2028/g, '\\u2028') // Escape line separator
    .replace(/\u2029/g, '\\u2029'); // Escape paragraph separator
}

/**
 * Formats a BlogTag object as TypeScript code
 */
function formatBlogTag(tag: BlogTag, indent: string = '    '): string {
  return `${indent}{
${indent}  label: "${escapeString(tag.label)}",
${indent}  permalink: "${escapeString(tag.permalink)}"
${indent}}`;
}

/**
 * Formats a BlogAuthor object as TypeScript code
 */
function formatBlogAuthor(author: BlogAuthor, indent: string = '    '): string {
  const lines = [
    `${indent}{`,
    `${indent}  name: "${escapeString(author.name)}",`,
    `${indent}  key: "${escapeString(author.key)}"`
  ];

  if (author.title) {
    lines.push(`${indent}  title: "${escapeString(author.title)}",`);
  }
  if (author.url) {
    lines.push(`${indent}  url: "${escapeString(author.url)}",`);
  }
  if (author.imageURL) {
    lines.push(`${indent}  imageURL: "${escapeString(author.imageURL)}",`);
  }

  lines.push(`${indent}}`);
  return lines.join('\n');
}

/**
 * Formats a BlogPostMetadata object as TypeScript code
 */
function formatBlogPostMetadata(metadata: BlogPostMetadata, indent: string = '    '): string {
  const tagsFormatted = metadata.tags.length > 0
    ? `[\n${metadata.tags.map(tag => formatBlogTag(tag, indent + '    ')).join(',\n')}\n${indent}  ]`
    : '[]';

  const authorsFormatted = metadata.authors.length > 0
    ? `[\n${metadata.authors.map(author => formatBlogAuthor(author, indent + '    ')).join(',\n')}\n${indent}  ]`
    : '[]';

  return `${indent}{
${indent}  permalink: "${escapeString(metadata.permalink)}",
${indent}  title: "${escapeString(metadata.title)}",${metadata.description ? `\n${indent}  description: "${escapeString(metadata.description)}",` : ''}
${indent}  date: "${escapeString(metadata.date)}",
${indent}  formattedDate: "${escapeString(metadata.formattedDate)}",
${indent}  tags: ${tagsFormatted},
${indent}  readingTime: ${metadata.readingTime},
${indent}  authors: ${authorsFormatted}
${indent}}`;
}

/**
 * Formats a BlogPost object as TypeScript code
 */
function formatBlogPost(post: BlogPost, indent: string = '  '): string {
  return `${indent}{
${indent}  id: "${escapeString(post.id)}",
${indent}  metadata: ${formatBlogPostMetadata(post.metadata, indent + '  ')}
${indent}}`;
}

/**
 * Formats a year group as TypeScript code
 */
function formatYearGroup(yearGroup: { year: string; posts: BlogPost[] }, indent: string = '    '): string {
  const postsFormatted = yearGroup.posts.length > 0
    ? `[\n${yearGroup.posts.map(post => formatBlogPost(post, indent + '    ')).join(',\n')}\n${indent}  ]`
    : '[]';

  return `${indent}{
${indent}  year: "${escapeString(yearGroup.year)}",
${indent}  posts: ${postsFormatted}
${indent}}`;
}

/**
 * Formats a tag group as TypeScript code
 */
function formatTagGroup(tagGroup: { tag: BlogTag; posts: BlogPost[] }, indent: string = '    '): string {
  const postsFormatted = tagGroup.posts.length > 0
    ? `[\n${tagGroup.posts.map(post => formatBlogPost(post, indent + '    ')).join(',\n')}\n${indent}  ]`
    : '[]';

  return `${indent}{
${indent}  tag: ${formatBlogTag(tagGroup.tag, indent + '  ')},
${indent}  posts: ${postsFormatted}
${indent}}`;
}

/**
 * Generates the content for the data.ts file
 */
export function generateDataFileContent(blogArchive: BlogArchive): string {
  const timestamp = new Date().toISOString();
  
  const postsFormatted = blogArchive.posts.length > 0
    ? `[\n${blogArchive.posts.map(post => formatBlogPost(post)).join(',\n')}\n  ]`
    : '[]';

  const yearsFormatted = blogArchive.years.length > 0
    ? `[\n${blogArchive.years.map(year => formatYearGroup(year)).join(',\n')}\n  ]`
    : '[]';

  const tagsFormatted = blogArchive.tags.length > 0
    ? `[\n${blogArchive.tags.map(tag => formatTagGroup(tag)).join(',\n')}\n  ]`
    : '[]';

  return `/**
 * Generated blog data
 * This file is generated by the blog data plugin - do not edit manually
 * Generated at: ${timestamp}
 */

import type { BlogArchive } from './types';

export const blogArchive: BlogArchive = {
  posts: ${postsFormatted},
  totalCount: ${blogArchive.totalCount},
  years: ${yearsFormatted},
  tags: ${tagsFormatted}
};
`;
}

/**
 * Generates the content for the types.ts file
 */
export function generateTypesFileContent(): string {
  const timestamp = new Date().toISOString();
  
  return `/**
 * TypeScript interfaces for blog data plugin
 * Generated by blog data plugin - do not edit manually
 * Generated at: ${timestamp}
 */

export interface BlogTag {
  label: string;
  permalink: string;
}

export interface BlogAuthor {
  name: string;
  key: string;
  title?: string;
  url?: string;
  imageURL?: string;
}

export interface BlogPostMetadata {
  permalink: string;
  title: string;
  description?: string;
  date: string;
  formattedDate: string;
  tags: BlogTag[];
  readingTime: number;
  authors: BlogAuthor[];
}

export interface BlogPost {
  id: string;
  metadata: BlogPostMetadata;
}

export interface BlogArchive {
  posts: BlogPost[];
  totalCount: number;
  years: Array<{
    year: string;
    posts: BlogPost[];
  }>;
  tags: Array<{
    tag: BlogTag;
    posts: BlogPost[];
  }>;
}
`;
}

/**
 * Generates the content for the index.ts file
 */
export function generateIndexFileContent(): string {
  const timestamp = new Date().toISOString();
  
  return `/**
 * Generated blog data exports
 * This file is generated by the blog data plugin - do not edit manually
 * Generated at: ${timestamp}
 */

export * from './types';
export * from './data';
`;
}

/**
 * Writes content to a file using Docusaurus actions.createData()
 * This is the preferred method for Docusaurus plugins
 */
export async function writeDataFile(
  actions: any,
  filename: string,
  content: string
): Promise<string> {
  try {
    const dataPath = await actions.createData(filename, content);
    return dataPath;
  } catch (error) {
    throw new Error(`Failed to write data file ${filename}: ${error}`);
  }
}

/**
 * Validates that the blog archive data is properly formatted
 */
export function validateBlogArchive(blogArchive: BlogArchive): void {
  if (!blogArchive || typeof blogArchive !== 'object') {
    throw new Error('Blog archive must be an object');
  }

  if (!Array.isArray(blogArchive.posts)) {
    throw new Error('Blog archive posts must be an array');
  }

  if (typeof blogArchive.totalCount !== 'number') {
    throw new Error('Blog archive totalCount must be a number');
  }

  if (!Array.isArray(blogArchive.years)) {
    throw new Error('Blog archive years must be an array');
  }

  if (!Array.isArray(blogArchive.tags)) {
    throw new Error('Blog archive tags must be an array');
  }

  // Validate posts
  for (const post of blogArchive.posts) {
    if (!post.id || typeof post.id !== 'string') {
      throw new Error('Each blog post must have a string id');
    }
    
    if (!post.metadata || typeof post.metadata !== 'object') {
      throw new Error('Each blog post must have metadata');
    }

    const { metadata } = post;
    if (!metadata.permalink || typeof metadata.permalink !== 'string') {
      throw new Error('Blog post metadata must have a string permalink');
    }

    if (!metadata.title || typeof metadata.title !== 'string') {
      throw new Error('Blog post metadata must have a string title');
    }

    if (!metadata.date || typeof metadata.date !== 'string') {
      throw new Error('Blog post metadata must have a string date');
    }

    if (!metadata.formattedDate || typeof metadata.formattedDate !== 'string') {
      throw new Error('Blog post metadata must have a string formattedDate');
    }

    if (!Array.isArray(metadata.tags)) {
      throw new Error('Blog post metadata tags must be an array');
    }

    if (typeof metadata.readingTime !== 'number') {
      throw new Error('Blog post metadata readingTime must be a number');
    }

    if (!Array.isArray(metadata.authors)) {
      throw new Error('Blog post metadata authors must be an array');
    }
  }
}

/**
 * Creates a minimal empty blog archive for initial generation
 */
export function createEmptyBlogArchive(): BlogArchive {
  return {
    posts: [],
    totalCount: 0,
    years: [],
    tags: []
  };
}